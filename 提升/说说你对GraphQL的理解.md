GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。

和SQL一样，GraphQL是一门查询语言（Query Language）
同样和SQL一样的是，GraphQL也是一套规范，就像MySQL是SQL的一套实现一样，Apollo, Relay...也是GraphQL规范的实现
与SQL不同的是，SQL的数据源是数据库，而GraphQL的数据源可以是各种各样的REST API，可以是各种服务/微服务，甚至可以是数据库


下面介绍一下GraphQL的有哪些好处：

请求你所要的数据不多不少

获取多个资源只用一个请求

自定义接口数据的字段

强大的开发者工具

API 演进无需划分版本

<!-- https://juejin.cn/post/6844903545276203022 -->


社区有大量 GraphQL 与传统 API 解决方案（含 REST API）对比文章，总结下来，传统 API 存在以下问题：

接口数量众多维护成本高：接口的数量通常由业务场景的数量决定，为了尽量减少接口数量，服务端工程师通常会对业务做抽象，首先构建粒度较小的数据接口，再根据业务场景对数据接口进行组合，对外暴露业务接口，即便这样，服务端对前端暴露的接口数量还是非常多，因为业务总是多变的。
接口扩展成本高：出于带宽的考虑移动端我们要求接口返回尽量少的字段，PC 端通常要展现更多字段；考虑首屏性能，我们又要求对接口做合并；传统 API 应对这些需求，前后端都面临改造，成本较高。
接口响应的数据格式无法预知：由于接口文档几乎总是不能及时更新，前端工程师无法预知接口响应的数据格式，影响前端开发进度。

针对以上问题，GraphQL 给出了较为完善的解决方案。


原理弄清楚之后我们需要对 GraphQL 这门技术的边界有一个清醒的认识：


客户端边界：核心能力是将请求参数按照服务端定义好的 AST 语法树规范拼装成客户端 Schema 字符串，实现方案大家可参考apollo提供的 Webpack 插件 ，当然也有一些 GraphQL 客户端连发送 Ajax 请求的活儿也干了，无非是在底层调用其他类库比如 axios 发请求。


服务端边界：核心能力是识别客户端 Schema 字符串，并通过服务端 Schema 调用底层的数据服务按需返回用户想要的数据，至于底层数据源来自哪里（数据库或者三方接口），以何种方式获取数据（直连数据库或者 ORM 方法调用），这些不属于 GraphQL  关心的范畴。

<!-- https://juejin.cn/post/6844903679640731655 -->


GraphQL缺点：
查询限速和权限评估等很难实现。
类型和数据加载器的工作方式，如果不编写完整的 module 就分组查询，则难以有效的方式将查询绑定到数据库层。
验证仅检查类型，因此您仍需要某种 JSON  schema 来执行其他格式验证。
GraphQL 查询只允许 left join，因此像 INNER JOIN 加过滤这种重新创建 SQL 就变得很棘手了。
来自像 Relay 这样的框架强加的分页（连接）还是一团糟。


<!-- https://juejin.cn/post/6844903811006332935 -->

GraphQL为我们解决了什么问题呢？
简单的说，站在前端角度，很多文章都会提到过为了取代Restful API，稍微具体点：

API字段的定制化，按需取字段
API的聚合，一次请求拿到所有的数据
后端不再需要维护接口的版本号了
完备的类型校验机制，提供了更健壮的接口
。。。



<!-- 优点 -->
一种用于 API 的查询语言
GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。
请求你所要的数据不多不少
向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。 GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。
获取多个资源只用一个请求
GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的 REST API 请求多个资源时得载入多个 URL，而 GraphQL 可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。
描述所有的可能类型系统
GraphQL API 基于类型和字段的方式进行组织，而非入口端点。你可以通过一个单一入口端点得到你所有的数据能力。GraphQL 使用类型来保证应用只请求可能的数据，还提供了清晰的辅助性错误信息。应用可以使用类型，而避免编写手动解析代码。
快步前进强大的开发者工具
不用离开编辑器就能准确知道你可以从 API 中请求的数据，发送查询之前就能高亮潜在问题，高级代码智能提示。利用 API 的类型系统，GraphQL 让你可以更简单地构建如同GraphiQL的强大工具。
API 演进无需划分版本
给你的 GraphQL API 添加字段和类型而无需影响现有查询。老旧的字段可以废弃，从工具中隐藏。通过使用单一演进版本，GraphQL API 使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码。
使用你现有的数据和代码
GraphQL 让你的整个应用共享一套 API，而不用被限制于特定存储引擎。GraphQL 引擎已经有多种语言实现，通过 GraphQL API 能够更好利用你的现有数据和代码。你只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们。



正如尤雨溪所说，为什么 GraphQL 两三年前没有广泛使用起来呢，可能有下面两个原因：
GraphQL 的 field resolve 如果按照 naive 的方式来写，每一个 field 都对数据库直接跑一个 query，会产生大量冗余 query，虽然网络层面的请求数被优化了，但数据库查询可能会成为性能瓶颈，这里面有很大的优化空间，但并不是那么容易做。FB 本身没有这个问题，因为他们内部数据库这一层也是抽象掉的，写 GraphQL 接口的人不需要顾虑 query 优化的问题。
GraphQL 的利好主要是在于前端的开发效率，但落地却需要服务端的全力配合。如果是小公司或者整个公司都是全栈，那可能可以做，但在很多前后端分工比较明确的团队里，要推动 GraphQL 还是会遇到各种协作上的阻力。
大约可以概括为性能瓶颈和团队分工的原因，希望随着社区的发展，基础设施的完善，会渐渐有完善的解决方案提出，让广大前后端开发者们可以早日用上此利器。



GraphQL 的优缺点
优点

所见即所得：所写请求体即为最终数据结构
减少网络请求：复杂数据的获取也可以一次请求完成
Schema 即文档：定义的 Schema 也规定了请求的规则
类型检查：严格的类型检查能够消除一定的认为失误

缺点

增加了服务端实现的复杂度：一些业务可能无法迁移使用 GraphQL，虽然可以使用中间件的方式将原业务的请求进行代理，这无疑也将增加复杂度和资源的消耗



<!-- https://juejin.cn/post/6844903641996869645 -->